# Двоичные деревья поиска

Создать двоичное дерево поиска, реализовать один из вариантов балансировки. Сравнить эффективность алгоритмов на случайных и упорядоченных данных. 
- Двоичное дерево поиска, 
- АВЛ дерево,
- Декартово дерево.

## Результаты

### Сравнительная таблица производительности алгоритмов работы бинарных деревьев поиска (ms)
N = 1 000 0000 

| | Всавка N чисел в случайном порядке | Всавка N чисел в возрастающем порядке | Поиск N/10 чисел в случайном порядке | Поиск N/10 чисел в возрастающем порядке | Удаление N/10 чисел в случайном порядке | Удаление N/10 чисел в возрастающем порядке |
| :------ | :-----: | :-----: | :-----: | :-----: | :-----: | :-----: |
| Binary Search Tree | 684 | Stack overflow | 61 | - | 79 | - |
| AVL Tree | 600 | 216 | 46 | 17 | 108 | 28 |
| Treap | 1207 | 120 | 76 | 25 | 179 | 61 |


### Вывод
Самым производительным оказалось AVL дерево, возможно это следствие балансировки после операций вставки и удаления. Далее идет обычное дерево поиска, но в него невозможно добавить большой объем отсортированных ключей ввиду переполнения стэка вызовов (в моем случае максимум 29635) и это большой минус. Treap имеет неплохие показатели и лучшие на вставку ключей в возрастающем порядке, в то время как вставка в случайном порядке на больших объемах имеет самый низкий результат. 
